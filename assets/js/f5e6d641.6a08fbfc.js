"use strict";(self.webpackChunkdatalogic_github_io=self.webpackChunkdatalogic_github_io||[]).push([[311],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return h}});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(t),m=i,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||r;return t?a.createElement(h,l(l({ref:n},p),{},{components:t})):a.createElement(h,l({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[u]="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=t[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},85162:function(e,n,t){t.d(n,{Z:function(){return l}});var a=t(67294),i=t(86010),r={tabItem:"tabItem_Ymn6"};function l(e){var n=e.children,t=e.hidden,l=e.className;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r.tabItem,l),hidden:t},n)}},74866:function(e,n,t){t.d(n,{Z:function(){return I}});var a=t(87462),i=t(67294),r=t(86010),l=t(12466),o=t(16550),s=t(91980),c=t(67392),p=t(50012);function u(e){return function(e){var n,t;return null!=(n=null==(t=i.Children.map(e,(function(e){if(!e||(0,i.isValidElement)(e)&&(n=e.props)&&"object"==typeof n&&"value"in n)return e;var n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}(e).map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}}))}function d(e){var n=e.values,t=e.children;return(0,i.useMemo)((function(){var e=null!=n?n:u(t);return function(e){var n=(0,c.l)(e,(function(e,n){return e.value===n.value}));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function m(e){var n=e.value;return e.tabValues.some((function(e){return e.value===n}))}function h(e){var n=e.queryString,t=void 0!==n&&n,a=e.groupId,r=(0,o.k6)(),l=function(e){var n=e.queryString,t=void 0!==n&&n,a=e.groupId;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:t,groupId:a});return[(0,s._X)(l),(0,i.useCallback)((function(e){if(l){var n=new URLSearchParams(r.location.search);n.set(l,e),r.replace(Object.assign({},r.location,{search:n.toString()}))}}),[l,r])]}function f(e){var n,t,a,r,l=e.defaultValue,o=e.queryString,s=void 0!==o&&o,c=e.groupId,u=d(e),f=(0,i.useState)((function(){return function(e){var n,t=e.defaultValue,a=e.tabValues;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}var i=null!=(n=a.find((function(e){return e.default})))?n:a[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:l,tabValues:u})})),g=f[0],k=f[1],S=h({queryString:s,groupId:c}),O=S[0],v=S[1],I=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:c}.groupId),t=(0,p.Nk)(n),a=t[0],r=t[1],[a,(0,i.useCallback)((function(e){n&&r.set(e)}),[n,r])]),C=I[0],b=I[1],N=function(){var e=null!=O?O:C;return m({value:e,tabValues:u})?e:null}();return(0,i.useLayoutEffect)((function(){N&&k(N)}),[N]),{selectedValue:g,selectValue:(0,i.useCallback)((function(e){if(!m({value:e,tabValues:u}))throw new Error("Can't select invalid tab value="+e);k(e),v(e),b(e)}),[v,b,u]),tabValues:u}}var g=t(72389),k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function S(e){var n=e.className,t=e.block,o=e.selectedValue,s=e.selectValue,c=e.tabValues,p=[],u=(0,l.o5)().blockElementScrollPositionUntilNextRender,d=function(e){var n=e.currentTarget,t=p.indexOf(n),a=c[t].value;a!==o&&(u(n),s(a))},m=function(e){var n,t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":var a,i=p.indexOf(e.currentTarget)+1;t=null!=(a=p[i])?a:p[0];break;case"ArrowLeft":var r,l=p.indexOf(e.currentTarget)-1;t=null!=(r=p[l])?r:p[p.length-1]}null==(n=t)||n.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},n)},c.map((function(e){var n=e.value,t=e.label,l=e.attributes;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:function(e){return p.push(e)},onKeyDown:m,onClick:d},l,{className:(0,r.Z)("tabs__item",k.tabItem,null==l?void 0:l.className,{"tabs__item--active":o===n})}),null!=t?t:n)})))}function O(e){var n=e.lazy,t=e.children,a=e.selectedValue,r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){var l=r.find((function(e){return e.props.value===a}));return l?(0,i.cloneElement)(l,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},r.map((function(e,n){return(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==a})})))}function v(e){var n=f(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",k.tabList)},i.createElement(S,(0,a.Z)({},e,n)),i.createElement(O,(0,a.Z)({},e,n)))}function I(e){var n=(0,g.Z)();return i.createElement(v,(0,a.Z)({key:String(n)},e))}},93561:function(e,n,t){t.r(n),t.d(n,{Img:function(){return d},assets:function(){return p},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return u}});var a=t(87462),i=t(63366),r=(t(67294),t(3905)),l=(t(74866),t(85162),["components"]),o={id:"tutorialcppscale",title:"C++ Live Weight Reader Tutorial",sidebar_label:"C++ Live Weight Reader Tutorial"},s=void 0,c={unversionedId:"opos/develop/tutorialcppscale",id:"opos/develop/tutorialcppscale",title:"C++ Live Weight Reader Tutorial",description:"Introduction",source:"@site/docs/opos/develop/tutorialcppscale.md",sourceDirName:"opos/develop",slug:"/opos/develop/tutorialcppscale",permalink:"/opos/develop/tutorialcppscale",draft:!1,tags:[],version:"current",frontMatter:{id:"tutorialcppscale",title:"C++ Live Weight Reader Tutorial",sidebar_label:"C++ Live Weight Reader Tutorial"},sidebar:"OPOS",previous:{title:"C++ Barcode Reader Tutorial",permalink:"/opos/develop/tutorialcppscanner"},next:{title:"C# Barcode Reader Tutorial",permalink:"/opos/develop/tutorialcsharpscanner"}},p={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Creating a project",id:"creating-a-project",level:2},{value:"Exposing OPOS control objects",id:"exposing-opos-control-objects",level:2},{value:"Creating the OPOS scale interface",id:"creating-the-opos-scale-interface",level:2},{value:"Accessing the OPOS Scale interface",id:"accessing-the-opos-scale-interface",level:2},{value:"Creating a sink for the scale",id:"creating-a-sink-for-the-scale",level:2},{value:"Implementing IUnknown",id:"implementing-iunknown",level:3},{value:'Implementing IDispatch<a name="idispatch"></a>',id:"implementing-idispatch",level:4},{value:"Implementing event functions",id:"implementing-event-functions",level:4},{value:"Connecting the scale and the sink",id:"connecting-the-scale-and-the-sink",level:2},{value:"Tying it all together",id:"tying-it-all-together",level:2}],d=function(e){var n=e.src;return(0,r.kt)("img",{src:n,style:{maxWidth:"750px",maxHeight:"750px"}})},m={toc:u,Img:d},h="wrapper";function f(e){var n=e.components,t=(0,i.Z)(e,l);return(0,r.kt)(h,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"In this tutorial, we will be creating a simple console application in C++ that opens, claims and enables a scale device and provides a live weight readings of items placed on the scale platter. This tutorial only covers a very basic aspect of development using OPOS with C++, but should suffice as a starting point for any application that looks to read weights from a Datalogic scale device."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"Developing an application for a Datalogic scale device requires you to first have Datalogic's OPOS installed. The OPOS installer ensures the required ActiveX Controls are registered and any supporting files are present."),(0,r.kt)("h2",{id:"creating-a-project"},"Creating a project"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Using Visual Studio 2019, navigate to ",(0,r.kt)("strong",{parentName:"p"},"File > New > Project ...")),(0,r.kt)(d,{src:"/img/opos/develop/cpp/filenewproject.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"In the ",(0,r.kt)("strong",{parentName:"p"},"Create a new project")," dialog, set the filter to ",(0,r.kt)("strong",{parentName:"p"},"C++"),", select ",(0,r.kt)("strong",{parentName:"p"},"Console App")," and select ",(0,r.kt)("strong",{parentName:"p"},"Next")),(0,r.kt)(d,{src:"/img/opos/develop/cpp/createnewproject.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"In the ",(0,r.kt)("strong",{parentName:"p"},"Configure your new project")," dialog, declare your ",(0,r.kt)("strong",{parentName:"p"},"Project name"),", ",(0,r.kt)("strong",{parentName:"p"},"Location")," and ",(0,r.kt)("strong",{parentName:"p"},"Solution name")," as desired and then select ",(0,r.kt)("strong",{parentName:"p"},"Create"),"."),(0,r.kt)(d,{src:"/img/opos/develop/cpp/scale/configurenewproject.png",mdxType:"Img"}))),(0,r.kt)("h2",{id:"exposing-opos-control-objects"},"Exposing OPOS control objects"),(0,r.kt)("p",null,"The very first step is to reference the scale ActiveX Control by its ProgID (Programmatic Identifier) using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#import")," directive."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#import "progid:OPOS.Scale"\n\nint main()\n{\n    return 0;\n}\n')),(0,r.kt)("p",null,"Compiling the project at this point, the ",(0,r.kt)("inlineCode",{parentName:"p"},"#import")," directive generates two files in your ",(0,r.kt)("inlineCode",{parentName:"p"},"$(Configuration)")," folder (i.e. Debug/Release). ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScale.tlh")," is the Type Library Header and ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScale.tli")," is the Type Library Interface. These files contain generated type information that bridges the COM object's interface with C++ language constructs."),(0,r.kt)("p",null,"While this makes the compiler aware of the COM object you're accessing, you'll likely find it helpful to make the Visual Studio IDE aware of of it as well; to do this you'll need to import the type library. Inside ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScale.tlh")," are a series of forward declared structs. The first struct reads:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct __declspec(uuid("<some-unique-identifier>"))\n/* LIBID */ __OposScale_CCO;\n')),(0,r.kt)("p",null,"Adding ",(0,r.kt)("inlineCode",{parentName:"p"},'#import "libid:<some-unique-identifier>"')," to your project will inform the IDE of the COM interface and everything in the namespace OposScale_CCO, but is not required for compilation."),(0,r.kt)("p",null,"Now your application should look similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// This import statement causes generation of OPOSScale.tlh and OPOSScale.tli\n#import "progid:OPOS.Scale"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScale_CCO, but is not required for compilation.\n#import "libid:ccb90170-b81e-11d2-ab74-0040054c3719"\n\nint main()\n{\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"creating-the-opos-scale-interface"},"Creating the OPOS scale interface"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"CoInitializeEx()")," must be called near the start of program to load and initialize the COM library and ",(0,r.kt)("inlineCode",{parentName:"p"},"CoUninitialize()")," must be called near the end of the program to unload the COM library."),(0,r.kt)("p",null,"The scale is implemented using the smart pointer ",(0,r.kt)("inlineCode",{parentName:"p"},"IOPOSScalePtr")," defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScale.tlh")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"_COM_SMARTPTR_TYPEDEF(IOPOSScale, __uuidof(IOPOSScale))"),", based on the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/cpp/cpp/com-ptr-t-class"},"_com_ptr_t class"),"."),(0,r.kt)("p",null,"An instance of the scale is created by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"_com_ptr_t::CreateInstance(const char *progid)")," and is release by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"_com_ptr_t::Release()")," when no longer needed. Failure to release the object can cause problems with an actual POS system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// This import statement causes generation of OPOSScale.tlh and OPOSScale.tli\n#import "progid:OPOS.Scale"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScale_CCO, but is not required for compilation.\n#import "libid:ccb90170-b81e-11d2-ab74-0040054c3719"\n\nint main()\n{\n    // Load and initialize the COM library.\n    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\n    // Create a COM object and point to it.\n    OposScale_CCO::IOPOSScalePtr scale; \n    scale.CreateInstance("OPOS.Scale"); \n\n    //\n    // more to come .... \n    //\n\n    // Release the COM object\n    scale.Release(); \n\n    // Unload the COM library.\n    CoUninitialize(); \n    return 0;\n}\n')),(0,r.kt)("h2",{id:"accessing-the-opos-scale-interface"},"Accessing the OPOS Scale interface"),(0,r.kt)("p",null,"At this point, you are ready to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"scale")," object."),(0,r.kt)("p",null,"The OPOS standard defines a general sequence to access a device:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"open"),": open a context to the device"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"claim"),": claim control over the device"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"enable"),": enable the device's operation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"disable"),": disable the device's  operation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"release"),": release control over the device"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"close"),": close the context to the device")),(0,r.kt)("p",null,"Opening a scale context requires you to reference a ",(0,r.kt)("em",{parentName:"p"},"device profile")," (a device profile simply being a name representing a set of parameters relevant to the device). When OPOS is installed, scale profiles are seen as the subkey names installed under the UPOS-specified registry key ",(0,r.kt)("inlineCode",{parentName:"p"},"HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\OLEforRetail\\ServiceOPOS\\SCALE"),". It is your choice whether you want to programmatically obtain the profile names from the registry or to simply hard-code them in your application."),(0,r.kt)("p",null,"If the scale context is successfully opened, you can then claim the device, gaining exclusive access to it. And if the device is successfully claimed, you can then enable it to perform subsequent operations."),(0,r.kt)("p",null,"Enabling live weight reading requires you to include the header file ",(0,r.kt)("inlineCode",{parentName:"p"},"OposScal.h"),", found in the distribution (typically under C:\\Program Files (x86)\\DLSOPOS\\Controls\\OposScal.h)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <windows.h>\n\n#include <string>\n\n// For access to scale constants (e.g. SCAL_SN_ENABLED)\n#include "OposScal.h"\n\n// This import statement causes generation of OPOSScale.tlh and OPOSScale.tli\n#import "progid:OPOS.Scale"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScale_CCO, but is not required for compilation.\n#import "libid:ccb90170-b81e-11d2-ab74-0040054c3719"\n\nint main()\n{\n    // Load and initialize the COM library.\n    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\n    // Create a COM object and point to it.\n    OposScale_CCO::IOPOSScalePtr scale; \n    scale.CreateInstance("OPOS.Scale"); \n\n    // Open a context with the scale (e.g. "USBScale").\n    std::string profileName("<your selected profile>");\n    scale->Open(profileName.c_str());\n\n    // Claim control of the scale using a 1000 millisecond timeout.\n    scale->ClaimDevice(1000L);\n    if (scale->Claimed)\n    {\n        // Enable the device.\n        scale->DeviceEnabled = true;        \n        // Tell the scale we intend to perform "live" weighing.\n        scale->StatusNotify = SCAL_SN_ENABLED;\n        // Enable transmission of event data.\n        scale->DataEventEnabled = true;\n\n        //\n        // more to come .... \n        //\n\n        // Disable, release and close the scale.\n        scale->DeviceEnabled = false;\n        scale->ReleaseDevice();\n        scale->Close();\n    }\n\n    // Release the COM object\n    scale.Release(); \n\n    // Unload the COM library.\n    CoUninitialize(); \n    return 0;\n}\n')),(0,r.kt)("h2",{id:"creating-a-sink-for-the-scale"},"Creating a sink for the scale"),(0,r.kt)("p",null,"To make the application useful, we must create a scale ",(0,r.kt)("em",{parentName:"p"},"sink")," (an object that receives input from the device)."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Using the Visual Studio 2019 ",(0,r.kt)("strong",{parentName:"p"},"Solution Explorer"),", right mouse click ",(0,r.kt)("strong",{parentName:"p"},"Header Files")),(0,r.kt)(d,{src:"/img/opos/develop/cpp/scale/addnewh_a.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"And when the dialog appears add a header file named ScaleSink.h"),(0,r.kt)(d,{src:"/img/opos/develop/cpp/scale/addnewh_b.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Using the Visual Studio 2019 ",(0,r.kt)("strong",{parentName:"p"},"Solution Explorer"),", right mouse click ",(0,r.kt)("strong",{parentName:"p"},"Source Files")),(0,r.kt)(d,{src:"/img/opos/develop/cpp/scale/addnew_a.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"And when the dialog appears add a source file named ScaleSink.cpp"),(0,r.kt)(d,{src:"/img/opos/develop/cpp/scale/addnew_b.png",mdxType:"Img"}))),(0,r.kt)("p",null,"The sink provides callback functions for use by the COM object. The callback functions provide implementations for the virtual methods of"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://msdn.microsoft.com/en-us/library/windows/desktop/ms221608(v=vs.85)"},"IDispatch")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680509(v=vs.85)"},"IUnknown"))),(0,r.kt)("p",null,"and the ",(0,r.kt)("em",{parentName:"p"},"dispatch")," methods of"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"_IOPOSScaleEvents (defined in ",(0,r.kt)("inlineCode",{parentName:"li"},"OPOSScale.tli"),")")),(0,r.kt)("p",null,"You will also notice enum ScaleEvent whose values are used by the COM object to map events to the dispatch methods. These will be discussed later in ",(0,r.kt)("a",{parentName:"p",href:"#idispatch"},"Implementing IDispatch"),"."),(0,r.kt)("p",null,"The scale sink is derived from OposScale_CCO::_IOPOSScaleEvents as follows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScaleSink.h\n\n// This import statement causes generation of OPOSScale.tlh and OPOSScale.tli\n#import "progid:OPOS.Scale"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScale_CCO, but is not required for compilation.\n#import "libid:ccb90170-b81e-11d2-ab74-0040054c3719"\n\nclass ScaleSink: public OposScale_CCO::_IOPOSScaleEvents\n{\npublic:\n\n    ScaleSink(OposScale_CCO::IOPOSScale &scaleObject)\n      : scale(scaleObject)\n      , ref(0)\n    {};\n\n    // IUnknown methods \n    IFACEMETHODIMP QueryInterface(REFIID riid, void **ppv);\n    IFACEMETHODIMP_(ULONG) AddRef();\n    IFACEMETHODIMP_(ULONG) Release();\n\n    // IDispatch methods\n    IFACEMETHODIMP GetTypeInfoCount(UINT *pctinfo);\n    IFACEMETHODIMP GetTypeInfo(UINT itinfo, \n        LCID lcid, ITypeInfo **iti);\n    IFACEMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *names, \n        UINT size, LCID lcid,DISPID *rgDispId);\n    IFACEMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, \n        WORD flags,DISPPARAMS *dispparams, VARIANT *result,\n        EXCEPINFO *exceptioninfo, UINT *argerr);\n\n    // _IOPOSScaleEvents methods\n    HRESULT DataEvent(long Status);\n    HRESULT DirectIOEvent(\n        long EventNumber,\n        long *Data,\n        BSTR *String);\n    HRESULT ErrorEvent(\n        long ResultCode,\n        long ResultCodeExtended,\n        long ErrorLocus,\n        long *ErrorResponse);\n    HRESULT StatusUpdateEvent(\n        long Data);\n\n    enum ScaleEvent: DISPID\n    {\n        Unused   = 0,\n        Data     = 1,\n        DirectIO = 2,\n        Error    = 3,\n        Reserved = 4,\n        StatusUpdate = 5,\n        Count    = 6\n    };\n\nprivate:\n\n    LONG ref;\n    OposScale_CCO::IOPOSScale &scale;\n};\n')),(0,r.kt)("h3",{id:"implementing-iunknown"},"Implementing IUnknown"),(0,r.kt)("p",null,"IUnknown is inherited by every COM interface. IUnknown has three virtual\nmethods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AddRef()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"QueryInterface()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Release()"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AddRef()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Release()")," are used for reference counting and ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryInterface()")," retrieves the supported interfaces of an object. The implementation of IUnknown is often as straight-forward as seen in this tutorial, which is loosely based off of the MSDN article ",(0,r.kt)("a",{parentName:"p",href:"https://msdn.microsoft.com/en-us/library/office/cc839627.aspx"},"Implementing IUnknown in C++"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScaleSink.cpp\n#include "ScaleSink.h"\n\nIFACEMETHODIMP ScaleSink::QueryInterface(REFIID riid, void **ppv)\n{\n    *ppv = nullptr;\n    IID id = __uuidof(OposScale_CCO::_IOPOSScaleEvents);\n    HRESULT hr = E_NOINTERFACE;\n    if (riid == IID_IUnknown || riid == IID_IDispatch || riid == id) {\n        *ppv = static_cast<OposScale_CCO::_IOPOSScaleEvents *>(this);\n        AddRef();\n        hr = S_OK;\n    }\n    return hr;\n}\n\nIFACEMETHODIMP_(ULONG) ScaleSink::AddRef()\n{\n    return ++ref;\n}\n\nIFACEMETHODIMP_(ULONG) ScaleSink::Release()\n{\n    if (--ref == 0)\n        delete this;\n    return ref;\n}\n')),(0,r.kt)("h4",{id:"implementing-idispatch"},"Implementing IDispatch",(0,r.kt)("a",{name:"idispatch"})),(0,r.kt)("p",null,"IDispatch has four virtual methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Invoke()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GetIDsOfNames()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GetTypeInfo()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GetTypeInfoCount()"))),(0,r.kt)("p",null,"The COM object calls ",(0,r.kt)("inlineCode",{parentName:"p"},"GetIDsOfNames()")," to obtain the dispatch id (",(0,r.kt)("inlineCode",{parentName:"p"},"DISPID"),") of a single class property or method. The dispatch id is then used by the COM object during subsequent calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"Invoke()"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Invoke()")," allows the COM object to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"_IOPOSScaleEvents")," methods of the sink class. The ",(0,r.kt)("inlineCode",{parentName:"p"},"DISPID")," parameter identifies the method to call and ",(0,r.kt)("inlineCode",{parentName:"p"},"DISPPARAMS")," contains the values to be passed to the function."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"GetTypeInfo()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GetTypeInfoCount()")," are used to retrieve type information, but provide no value in our case."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScaleSink.cpp\nIFACEMETHODIMP ScaleSink::GetTypeInfoCount(UINT *pctinfo) \n{\n    *pctinfo = 0;\n    return E_NOTIMPL;\n}\n\nIFACEMETHODIMP ScaleSink::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **iti)\n{\n    *iti = nullptr;\n    return E_NOTIMPL;\n}\n\nIFACEMETHODIMP ScaleSink::GetIDsOfNames(REFIID riid, LPOLESTR *names,\n    UINT size, LCID lcid, DISPID *dispids)\n{\n    if (wcscmp(names[0], L"StatusUpdateEvent") == 0)\n        dispids[0] = ScaleEvent::StatusUpdate;\n    else if (wcscmp(names[0], L"DirectIOEvent") == 0)\n        dispids[0] = ScaleEvent::DirectIO;\n    else if (wcscmp(names[0], L"ErrorEvent") == 0)\n        dispids[0] = ScaleEvent::Error;\n    else if (wcscmp(names[0], L"DataEvent") == 0)\n        dispids[0] = ScaleEvent::Data;\n    else\n        dispids[0] = -1;\n\n    return ((dispids[0] == -1) ? E_NOTIMPL : S_OK);\n}\n\nIFACEMETHODIMP ScaleSink::Invoke(DISPID dispid, REFIID riid, LCID lcid,\n    WORD flags, DISPPARAMS *dispparams, VARIANT *result,\n    EXCEPINFO *exceptioninfo, UINT *argerr) \n{\n    if (ScaleEvent::StatusUpdate == dispid)\n        return StatusUpdateEvent(dispparams->rgvarg[0].lVal);\n    else\n        return S_OK;\n}\n')),(0,r.kt)("h4",{id:"implementing-event-functions"},"Implementing event functions"),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"IDispatch")," implemented the scale sink will invoke its supported events. For the purpose of this tutorial, the scale event data is simply interpreted and printed to the console."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScaleSink.cpp\nHRESULT ScaleSink::StatusUpdateEvent(long Data)\n{\n if (Data == SCAL_SUE_STABLE_WEIGHT)\n  std::cout << WeightFormat(scale.ScaleLiveWeight) << std::endl;\n else if (Data == SCAL_SUE_WEIGHT_UNSTABLE)\n  std::cout << "Scale weight unstable" << std::endl;\n else if (Data == SCAL_SUE_WEIGHT_ZERO)\n  std::cout << WeightFormat(scale.ScaleLiveWeight) << std::endl;\n else if (Data == SCAL_SUE_WEIGHT_OVERWEIGHT)\n  std::cout << "Weight limit exceeded." << std::endl;\n else if (Data == SCAL_SUE_NOT_READY)\n  std::cout << "Scale not ready." << std::endl;\n else if (Data == SCAL_SUE_WEIGHT_UNDER_ZERO)\n  std::cout << "Scale under zero weight." << std::endl;\n else\n  std::cout << "Unknown status [" << Data << "]" << std::endl;\n\n return S_OK;\n}\n\nstd::string ScaleSink::WeightFormat(int weight)\n{\n std::string weightStr;\n\n std::string units = UnitAbbreviation(scale.WeightUnits);\n if (units.empty())\n {\n  weightStr = "Unknown weight unit";\n }\n else\n {\n  std::stringstream ss;\n  ss << std::fixed << std::setw(6) << std::setprecision(3) << (0.001 * (double)weight) << " " << units;\n  weightStr = ss.str();\n }\n\n return weightStr;\n}\n\nstd::string ScaleSink::UnitAbbreviation(int units)\n{\n std::string unitStr;\n\n switch (units)\n {\n case SCAL_WU_GRAM:     unitStr = "gr."; break;\n case SCAL_WU_KILOGRAM: unitStr = "kg."; break;\n case SCAL_WU_OUNCE:    unitStr = "oz."; break;\n case SCAL_WU_POUND:    unitStr = "lb."; break;\n }\n\n return unitStr;\n}\n')),(0,r.kt)("h2",{id:"connecting-the-scale-and-the-sink"},"Connecting the scale and the sink"),(0,r.kt)("p",null,"Now we must inform the scale of the sink. To do this query an ",(0,r.kt)("inlineCode",{parentName:"p"},"IConnectionPointContainer")," interface by calling\n",(0,r.kt)("inlineCode",{parentName:"p"},"QueryInterface()")," from the scale. On the connection point container, get the interface of the ",(0,r.kt)("inlineCode",{parentName:"p"},"_IOPOSScaleEvents")," connection point by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"FindConnectionPoint()"),". Now a connection can be established between the scale and the sink by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"Advise()")," on the connection point."),(0,r.kt)("p",null,"The following code can be seen in context in the segment ",(0,r.kt)("a",{parentName:"p",href:"#together"},"Tying it all together"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IConnectionPointContainer *cpc;\nscale->QueryInterface(IID_IConnectionPointContainer, (void **) &cpc);\n\nIConnectionPoint *cp; \ncpc->FindConnectionPoint(__uuidof(OposScale_CCO::_IOPOSScaleEvents), &cp);\ncpc->Release();\n\nScaleSink *sink = new ScaleSink(*scale); \nDWORD cookie;\ncp->Advise(sink, &cookie);\n")),(0,r.kt)("h2",{id:"tying-it-all-together"},"Tying it all together"),(0,r.kt)("p",null,"As any experienced developer knows, a huge part of writing code is defensive programming, guarding against potential errors. So be aware, for the sake of brevity, this tutorial has avoided addressing the myriad issues you may encounter."),(0,r.kt)("p",null,"That said, a more complete example can be found in the ",(0,r.kt)("a",{parentName:"p",href:"./datalogicoposexamples"},"Datalogic OPOS Examples"),"."),(0,r.kt)("p",null,"Refactoring a little, we can move shared #include and #import statements to a common location (ScaleSink.h in this tutorial)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScaleSink.h\n#include <windows.h>\n#include <string>\n#include <iostream>\n\n// For access to scale constants (e.g. SCAL_SN_ENABLED)\n#include "OposScal.h"\n\n// This import statement causes generation of OPOSScale.tlh and OPOSScale.tli\n#import "progid:OPOS.Scale"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScale_CCO, but is not required for compilation.\n#import "libid:ccb90170-b81e-11d2-ab74-0040054c3719"\n')),(0,r.kt)("p",null,"Doing that simplifies the main file a little. Finally, we can add the code connecting the scale to the sink.",(0,r.kt)("a",{name:"together"})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "ScaleSink.h"\n#include <processthreadsapi.h>\n\nstatic DWORD threadID;\nstatic BOOL handler(DWORD event);\n\nint main()\n{\n    // Setup the console program to exit gracefully.\n    threadID = GetCurrentThreadId();\n    SetConsoleCtrlHandler((PHANDLER_ROUTINE)(handler), TRUE);\n\n    // Load and initialize the COM library.\n    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\n    // Create a COM object and point to it.\n    OposScale_CCO::IOPOSScalePtr scale;\n    scale.CreateInstance("OPOS.Scale");\n\n    // Open a context with the scale (e.g. "USBScale").\n    std::string profileName("<your selected profile>");\n    scale->Open(profileName.c_str());\n\n    // Claim control of the scale using a 1000 millisecond timeout.\n    scale->ClaimDevice(1000L);\n    if (scale->Claimed)\n    {\n        // The scale has been opened and claimed.\n        \n        // Enable the device.\n        scale->DeviceEnabled = true;        \n        // Tell the scale we intend to perform "live" weighing.\n        scale->StatusNotify = SCAL_SN_ENABLED;\n        // Enable transmission of event data.\n        scale->DataEventEnabled = true;\n\n        // Determine whether scale is connectable\n        IConnectionPointContainer* cpc;\n        bool isConnectable = (scale->QueryInterface(IID_IConnectionPointContainer, (void**)&cpc) == S_OK);\n\n        if (isConnectable)\n        {\n            // Determine whether _IOPOSScaleEvents connection point is supported.\n            IConnectionPoint* cp;\n            bool haveConnectionPoint = (cpc->FindConnectionPoint(__uuidof(OposScale_CCO::_IOPOSScaleEvents), &cp) == S_OK);\n            cpc->Release();\n\n            if (haveConnectionPoint)\n            {\n                ScaleSink* sink = new ScaleSink(*scale);\n\n                // Connect cp with sink (subscribe to the sink).\n                // cookie is a token representing the connection,\n                // used later when deleting the connection.\n                DWORD cookie;\n                cp->Advise(sink, &cookie);\n\n                std::cout << "Press \\\'Ctrl + C\\\' to quit." << std::endl;\n\n                // The scale message loop. Events will be handled by the methods of the sink.\n                static MSG msg = { 0 };\n                while (GetMessage(&msg, 0, 0, 0))\n                {\n                    TranslateMessage(&msg);\n                    DispatchMessage(&msg);\n                }\n\n                // Delete the connection (unsubscribe from the sink).\n                cp->Unadvise(cookie);\n                cp->Release();\n            }\n        }\n\n        // Disable, release and close the scale.\n        scale->DeviceEnabled = false;\n        scale->ReleaseDevice();\n        scale->Close();\n    }\n\n    // Release the COM object\n    scale.Release();\n\n    // Unload libraries on this thread.\n    CoUninitialize();\n    return 0;\n}\n\nBOOL handler(DWORD event)\n{\n    PostThreadMessage(threadID, WM_QUIT, 0, 0);\n    return TRUE;\n}\n')))}f.isMDXComponent=!0}}]);