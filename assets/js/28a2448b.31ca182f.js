"use strict";(self.webpackChunkdatalogic_github_io=self.webpackChunkdatalogic_github_io||[]).push([[3982],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(t),m=r,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return t?a.createElement(h,o(o({ref:n},p),{},{components:t})):a.createElement(h,o({ref:n},p))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[d]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.d(n,{Z:()=>o});var a=t(67294),r=t(86010);const i={tabItem:"tabItem_Ymn6"};function o(e){let{children:n,hidden:t,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,o),hidden:t},n)}},74866:(e,n,t)=>{t.d(n,{Z:()=>I});var a=t(87462),r=t(67294),i=t(86010),o=t(12466),l=t(16550),s=t(91980),c=t(67392),p=t(50012);function d(e){return function(e){var n,t;return null!=(n=null==(t=r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}function u(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=n?n:d(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function m(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function h(e){let{queryString:n=!1,groupId:t}=e;const a=(0,l.k6)(),i=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,s._X)(i),(0,r.useCallback)((e=>{if(!i)return;const n=new URLSearchParams(a.location.search);n.set(i,e),a.replace({...a.location,search:n.toString()})}),[i,a])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,i=u(e),[o,l]=(0,r.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(n=a.find((e=>e.default)))?n:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:i}))),[s,c]=h({queryString:t,groupId:a}),[d,f]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[a,i]=(0,p.Nk)(t);return[a,(0,r.useCallback)((e=>{t&&i.set(e)}),[t,i])]}({groupId:a}),g=(()=>{const e=null!=s?s:d;return m({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error("Can't select invalid tab value="+e);l(e),c(e),f(e)}),[c,f,i]),tabValues:i}}var g=t(72389);const k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function O(e){let{className:n,block:t,selectedValue:l,selectValue:s,tabValues:c}=e;const p=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.o5)(),u=e=>{const n=e.currentTarget,t=p.indexOf(n),a=c[t].value;a!==l&&(d(n),s(a))},m=e=>{var n;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var a;const n=p.indexOf(e.currentTarget)+1;t=null!=(a=p[n])?a:p[0];break}case"ArrowLeft":{var r;const n=p.indexOf(e.currentTarget)-1;t=null!=(r=p[n])?r:p[p.length-1];break}}null==(n=t)||n.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":t},n)},c.map((e=>{let{value:n,label:t,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,key:n,ref:e=>p.push(e),onKeyDown:m,onClick:u},o,{className:(0,i.Z)("tabs__item",k.tabItem,null==o?void 0:o.className,{"tabs__item--active":l===n})}),null!=t?t:n)})))}function v(e){let{lazy:n,children:t,selectedValue:a}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},i.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==a}))))}function S(e){const n=f(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",k.tabList)},r.createElement(O,(0,a.Z)({},e,n)),r.createElement(v,(0,a.Z)({},e,n)))}function I(e){const n=(0,g.Z)();return r.createElement(S,(0,a.Z)({key:String(n)},e))}},30625:(e,n,t)=>{t.r(n),t.d(n,{Img:()=>p,assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(87462),r=(t(67294),t(3905));t(74866),t(85162);const i={id:"tutorialcppscanner",title:"C++ Barcode Reader Tutorial",sidebar_label:"C++ Barcode Reader Tutorial"},o=void 0,l={unversionedId:"opos/develop/tutorialcppscanner",id:"opos/develop/tutorialcppscanner",title:"C++ Barcode Reader Tutorial",description:"Introduction",source:"@site/docs/opos/develop/tutorialcppscanner.md",sourceDirName:"opos/develop",slug:"/opos/develop/tutorialcppscanner",permalink:"/opos/develop/tutorialcppscanner",draft:!1,tags:[],version:"current",frontMatter:{id:"tutorialcppscanner",title:"C++ Barcode Reader Tutorial",sidebar_label:"C++ Barcode Reader Tutorial"},sidebar:"OPOS",previous:{title:"Introduction to the OPOS Tutorials",permalink:"/opos/develop/tutorialintro"},next:{title:"C++ Live Weight Reader Tutorial",permalink:"/opos/develop/tutorialcppscale"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Creating a project",id:"creating-a-project",level:2},{value:"Exposing OPOS control objects",id:"exposing-opos-control-objects",level:2},{value:"Creating the OPOS scanner interface",id:"creating-the-opos-scanner-interface",level:2},{value:"Accessing the OPOS Scanner interface",id:"accessing-the-opos-scanner-interface",level:2},{value:"Creating a sink for the scanner",id:"creating-a-sink-for-the-scanner",level:2},{value:"Implementing IUnknown",id:"implementing-iunknown",level:3},{value:'Implementing IDispatch<a name="idispatch"></a>',id:"implementing-idispatch",level:4},{value:"Implementing event functions",id:"implementing-event-functions",level:4},{value:"Connecting the scanner and the sink",id:"connecting-the-scanner-and-the-sink",level:2},{value:"Tying it all together",id:"tying-it-all-together",level:2}],p=e=>{let{src:n}=e;return(0,r.kt)("img",{src:n,style:{maxWidth:"750px",maxHeight:"750px"}})},d={toc:c,Img:p},u="wrapper";function m(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"In this tutorial, we will be creating a simple console application in C++ that opens, claims and enables a scanner device and provides a mechanism to see what labels were scanned with that device. This tutorial only covers a very basic aspect of development using OPOS with C++, but should suffice as a starting point for any application that looks to read labels from a Datalogic scanning device."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"Developing an application for a Datalogic scanning device requires you to first have Datalogic's OPOS installed. The OPOS installer ensures the required ActiveX Controls are registered and any supporting files are present."),(0,r.kt)("h2",{id:"creating-a-project"},"Creating a project"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Using Visual Studio 2019, navigate to ",(0,r.kt)("strong",{parentName:"p"},"File > New > Project ...")),(0,r.kt)(p,{src:"/img/opos/develop/cpp/filenewproject.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"In the ",(0,r.kt)("strong",{parentName:"p"},"Create a new project")," dialog, set the filter to ",(0,r.kt)("strong",{parentName:"p"},"C++"),", select ",(0,r.kt)("strong",{parentName:"p"},"Console App")," and select ",(0,r.kt)("strong",{parentName:"p"},"Next")),(0,r.kt)(p,{src:"/img/opos/develop/cpp/createnewproject.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"In the ",(0,r.kt)("strong",{parentName:"p"},"Configure your new project")," dialog, declare your ",(0,r.kt)("strong",{parentName:"p"},"Project name"),", ",(0,r.kt)("strong",{parentName:"p"},"Location")," and ",(0,r.kt)("strong",{parentName:"p"},"Solution name")," as desired and then select ",(0,r.kt)("strong",{parentName:"p"},"Create"),"."),(0,r.kt)(p,{src:"/img/opos/develop/cpp/scanner/configurenewproject.png",mdxType:"Img"}))),(0,r.kt)("h2",{id:"exposing-opos-control-objects"},"Exposing OPOS control objects"),(0,r.kt)("p",null,"The very first step is to reference the scanner ActiveX Control by its ProgID (Programmatic Identifier) using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#import")," directive."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#import "progid:OPOS.Scanner"\n\nint main()\n{\n    return 0;\n}\n')),(0,r.kt)("p",null,"Compiling the project at this point, the ",(0,r.kt)("inlineCode",{parentName:"p"},"#import")," directive generates two files in your ",(0,r.kt)("inlineCode",{parentName:"p"},"$(Configuration)")," folder (i.e. Debug/Release). ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScanner.tlh")," is the Type Library Header and ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScanner.tli")," is the Type Library Interface. These files contain generated type information that bridges the COM object's interface with C++ language constructs."),(0,r.kt)("p",null,"While this makes the compiler aware of the COM object you're accessing, you'll likely find it helpful to make the Visual Studio IDE aware of of it as well; to do this you'll need to import the type library. Inside ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScanner.tlh")," are a series of forward declared structs. The first struct reads:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct __declspec(uuid("<some-unique-identifier>"))\n/* LIBID */ __OposScanner_CCO;\n')),(0,r.kt)("p",null,"Adding ",(0,r.kt)("inlineCode",{parentName:"p"},'#import "libid:<some-unique-identifier>"')," to your project will inform the IDE of the COM interface and everything in the namespace OposScanner_CCO, but is not required for compilation."),(0,r.kt)("p",null,"Now your application should look similar to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// This import statement causes generation of OPOSScanner.tlh and OPOSScanner.tli\n#import "progid:OPOS.Scanner"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScanner_CCO, but is not required for compilation.\n#import "libid:ccb90180-b81e-11d2-ab74-0040054c3719"\n\nint main()\n{\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"creating-the-opos-scanner-interface"},"Creating the OPOS scanner interface"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"CoInitializeEx()")," must be called near the start of program to load and initialize the COM library and ",(0,r.kt)("inlineCode",{parentName:"p"},"CoUninitialize()")," must be called near the end of the program to unload the COM library."),(0,r.kt)("p",null,"The scanner is implemented using the smart pointer ",(0,r.kt)("inlineCode",{parentName:"p"},"IOPOSScannerPtr")," defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScanner.tlh")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"_COM_SMARTPTR_TYPEDEF(IOPOSScanner, __uuidof(IOPOSScanner))"),", based on the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/cpp/cpp/com-ptr-t-class"},"_com_ptr_t class"),"."),(0,r.kt)("p",null,"An instance of the scanner is created by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"_com_ptr_t::CreateInstance(const char *progid)")," and is release by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"_com_ptr_t::Release()")," when no longer needed. Failure to release the object can cause problems with an actual POS system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// This import statement causes generation of OPOSScanner.tlh and OPOSScanner.tli\n#import "progid:OPOS.Scanner"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScanner_CCO, but is not required for compilation.\n#import "libid:ccb90180-b81e-11d2-ab74-0040054c3719"\n\nint main()\n{\n    // Load and initialize the COM library.\n    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\n    // Create a COM object and point to it.\n    OposScanner_CCO::IOPOSScannerPtr scanner; \n    scanner.CreateInstance("OPOS.Scanner"); \n\n    //\n    // more to come .... \n    //\n\n    // Release the COM object\n    scanner.Release(); \n\n    // Unload the COM library.\n    CoUninitialize(); \n    return 0;\n}\n')),(0,r.kt)("h2",{id:"accessing-the-opos-scanner-interface"},"Accessing the OPOS Scanner interface"),(0,r.kt)("p",null,"At this point, you are ready to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"scanner")," object."),(0,r.kt)("p",null,"The OPOS standard defines a general sequence to access a device:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"open"),": open a context to the device"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"claim"),": claim control over the device"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"enable"),": enable the device's operation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"disable"),": disable the device's  operation"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"release"),": release control over the device"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"close"),": close the context to the device")),(0,r.kt)("p",null,"Opening a scanner context requires you to reference a ",(0,r.kt)("em",{parentName:"p"},"device profile")," (a device profile simply being a name representing a set of parameters relevant to the device). When OPOS is installed, scanner profiles are seen as the subkey names installed under the UPOS-specified registry key ",(0,r.kt)("inlineCode",{parentName:"p"},"HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\OLEforRetail\\ServiceOPOS\\SCANNER"),". It is your choice whether you want to programmatically obtain the profile names from the registry or to simply hard-code them in your application."),(0,r.kt)("p",null,"If the scanner context is successfully opened, you can then claim the device, gaining exclusive access to it. And if the device is successfully claimed, you can then enable it to perform subsequent operations."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <string>\n\n// This import statement causes generation of OPOSScanner.tlh and OPOSScanner.tli\n#import "progid:OPOS.Scanner"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScanner_CCO, but is not required for compilation.\n#import "libid:ccb90180-b81e-11d2-ab74-0040054c3719"\n\nint main()\n{\n    // Load and initialize the COM library.\n    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\n    // Create a COM object and point to it.\n    OposScanner_CCO::IOPOSScannerPtr scanner; \n    scanner.CreateInstance("OPOS.Scanner"); \n\n    // Open a context with the scanner (e.g. "USBScanner").\n    std::string profileName("<your selected profile>");\n    scanner->Open(profileName.c_str());\n\n    // Claim control of the scanner using a 1000 millisecond timeout.\n    scanner->ClaimDevice(1000L);\n    if (scanner->Claimed)\n    {\n        // Enable the device, label decoding and transmission of event data.\n        scanner->DeviceEnabled = true;        \n        scanner->DataEventEnabled = true;\n        scanner->DecodeData = true;\n\n        //\n        // more to come .... \n        //\n\n        // Disable, release and close the scanner.\n        scanner->DeviceEnabled = false;\n        scanner->ReleaseDevice();\n        scanner->Close();\n    }\n\n    // Release the COM object\n    scanner.Release(); \n\n    // Unload the COM library.\n    CoUninitialize(); \n    return 0;\n}\n')),(0,r.kt)("h2",{id:"creating-a-sink-for-the-scanner"},"Creating a sink for the scanner"),(0,r.kt)("p",null,"To make the application useful, we must create a scanner ",(0,r.kt)("em",{parentName:"p"},"sink")," (an object that receives input from the device)."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Using the Visual Studio 2019 ",(0,r.kt)("strong",{parentName:"p"},"Solution Explorer"),", right mouse click ",(0,r.kt)("strong",{parentName:"p"},"Header Files")),(0,r.kt)(p,{src:"/img/opos/develop/cpp/scanner/addnewh_a.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"And when the dialog appears add a header file named ScannerSink.h"),(0,r.kt)(p,{src:"/img/opos/develop/cpp/scanner/addnewh_b.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Using the Visual Studio 2019 ",(0,r.kt)("strong",{parentName:"p"},"Solution Explorer"),", right mouse click ",(0,r.kt)("strong",{parentName:"p"},"Source Files")),(0,r.kt)(p,{src:"/img/opos/develop/cpp/scanner/addnew_a.png",mdxType:"Img"})),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"And when the dialog appears add a source file named ScannerSink.cpp"),(0,r.kt)(p,{src:"/img/opos/develop/cpp/scanner/addnew_b.png",mdxType:"Img"}))),(0,r.kt)("p",null,"The sink provides callback functions for use by the COM object. The callback functions provide implementations for the virtual methods of"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://msdn.microsoft.com/en-us/library/windows/desktop/ms221608(v=vs.85)"},"IDispatch")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://msdn.microsoft.com/en-us/library/windows/desktop/ms680509(v=vs.85)"},"IUnknown"))),(0,r.kt)("p",null,"and the ",(0,r.kt)("em",{parentName:"p"},"dispatch")," methods of"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"_IOPOSScannerEvents (defined in ",(0,r.kt)("inlineCode",{parentName:"li"},"OPOSScanner.tli"),")")),(0,r.kt)("p",null,"You will also notice enum ScannerEvent whose values are used by the COM object to map events to the dispatch methods. These will be discussed later in ",(0,r.kt)("a",{parentName:"p",href:"#idispatch"},"Implementing IDispatch"),"."),(0,r.kt)("p",null,"The scanner sink is derived from OposScanner_CCO::_IOPOSScannerEvents as follows"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScannerSink.h\n\n// This import statement causes generation of OPOSScanner.tlh and OPOSScanner.tli\n#import "progid:OPOS.Scanner"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScanner_CCO, but is not required for compilation.\n#import "libid:ccb90180-b81e-11d2-ab74-0040054c3719"\n\nclass ScannerSink: public OposScanner_CCO::_IOPOSScannerEvents\n{\npublic:\n\n    ScannerSink(OposScanner_CCO::IOPOSScanner &scannerObject)\n      : scanner(scannerObject)\n      , ref(0)\n    {};\n\n    // IUnknown methods \n    IFACEMETHODIMP QueryInterface(REFIID riid, void **ppv);\n    IFACEMETHODIMP_(ULONG) AddRef();\n    IFACEMETHODIMP_(ULONG) Release();\n\n    // IDispatch methods\n    IFACEMETHODIMP GetTypeInfoCount(UINT *pctinfo);\n    IFACEMETHODIMP GetTypeInfo(UINT itinfo, \n        LCID lcid, ITypeInfo **iti);\n    IFACEMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *names, \n        UINT size, LCID lcid,DISPID *rgDispId);\n    IFACEMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, \n        WORD flags,DISPPARAMS *dispparams, VARIANT *result,\n        EXCEPINFO *exceptioninfo, UINT *argerr);\n\n    // _IOPOSScannerEvents methods\n    HRESULT DataEvent(long Status);\n    HRESULT DirectIOEvent(\n        long EventNumber,\n        long *Data,\n        BSTR *String);\n    HRESULT ErrorEvent(\n        long ResultCode,\n        long ResultCodeExtended,\n        long ErrorLocus,\n        long *ErrorResponse);\n    HRESULT StatusUpdateEvent(\n        long Data);\n\n    enum ScannerEvent: DISPID\n    {\n        Unused   = 0,\n        Data     = 1,\n        DirectIO = 2,\n        Error    = 3,\n        Reserved = 4,\n        StatusUpdate = 5,\n        Count    = 6\n    };\n\nprivate:\n\n    LONG ref;\n    OposScanner_CCO::IOPOSScanner &scanner;\n};\n')),(0,r.kt)("h3",{id:"implementing-iunknown"},"Implementing IUnknown"),(0,r.kt)("p",null,"IUnknown is inherited by every COM interface. IUnknown has three virtual\nmethods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AddRef()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"QueryInterface()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Release()"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"AddRef()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Release()")," are used for reference counting and ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryInterface()")," retrieves the supported interfaces of an object. The implementation of IUnknown is often as straight-forward as seen in this tutorial, which is loosely based off of the MSDN article ",(0,r.kt)("a",{parentName:"p",href:"https://msdn.microsoft.com/en-us/library/office/cc839627.aspx"},"Implementing IUnknown in C++"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScannerSink.cpp\n#include "ScannerSink.h"\n\nIFACEMETHODIMP ScannerSink::QueryInterface(REFIID riid, void **ppv)\n{\n    *ppv = nullptr;\n    IID id = __uuidof(OposScanner_CCO::_IOPOSScannerEvents);\n    HRESULT hr = E_NOINTERFACE;\n    if (riid == IID_IUnknown || riid == IID_IDispatch || riid == id) {\n        *ppv = static_cast<OposScanner_CCO::_IOPOSScannerEvents *>(this);\n        AddRef();\n        hr = S_OK;\n    }\n    return hr;\n}\n\nIFACEMETHODIMP_(ULONG) ScannerSink::AddRef()\n{\n    return ++ref;\n}\n\nIFACEMETHODIMP_(ULONG) ScannerSink::Release()\n{\n    if (--ref == 0)\n        delete this;\n    return ref;\n}\n')),(0,r.kt)("h4",{id:"implementing-idispatch"},"Implementing IDispatch",(0,r.kt)("a",{name:"idispatch"})),(0,r.kt)("p",null,"IDispatch has four virtual methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Invoke()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GetIDsOfNames()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GetTypeInfo()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GetTypeInfoCount()"))),(0,r.kt)("p",null,"The COM object calls ",(0,r.kt)("inlineCode",{parentName:"p"},"GetIDsOfNames()")," to obtain the dispatch id (",(0,r.kt)("inlineCode",{parentName:"p"},"DISPID"),") of a single class property or method. The dispatch id is then used by the COM object during subsequent calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"Invoke()"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Invoke()")," allows the COM object to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"_IOPOSScannerEvents")," methods of the sink class. The ",(0,r.kt)("inlineCode",{parentName:"p"},"DISPID")," parameter identifies the method to call and ",(0,r.kt)("inlineCode",{parentName:"p"},"DISPPARAMS")," contains the values to be passed to the function."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"GetTypeInfo()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"GetTypeInfoCount()")," are used to retrieve type information, but provide no value in our case."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScannerSink.cpp\nIFACEMETHODIMP ScannerSink::GetTypeInfoCount(UINT *pctinfo) \n{\n    *pctinfo = 0;\n    return E_NOTIMPL;\n}\n\nIFACEMETHODIMP ScannerSink::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **iti)\n{\n    *iti = nullptr;\n    return E_NOTIMPL;\n}\n\nIFACEMETHODIMP ScannerSink::GetIDsOfNames(REFIID riid, LPOLESTR *names,\n    UINT size, LCID lcid, DISPID *dispids)\n{\n    if (wcscmp(names[0], L"StatusUpdateEvent") == 0)\n        dispids[0] = ScannerEvent::StatusUpdate;\n    else if (wcscmp(names[0], L"DirectIOEvent") == 0)\n        dispids[0] = ScannerEvent::DirectIO;\n    else if (wcscmp(names[0], L"ErrorEvent") == 0)\n        dispids[0] = ScannerEvent::Error;\n    else if (wcscmp(names[0], L"DataEvent") == 0)\n        dispids[0] = ScannerEvent::Data;\n    else\n        dispids[0] = -1;\n\n    return ((dispids[0] == -1) ? E_NOTIMPL : S_OK);\n}\n\nIFACEMETHODIMP ScannerSink::Invoke(DISPID dispid, REFIID riid, LCID lcid,\n    WORD flags, DISPPARAMS *dispparams, VARIANT *result,\n    EXCEPINFO *exceptioninfo, UINT *argerr) \n{\n    if (ScannerEvent::Data == dispid)\n        return DataEvent(dispparams->rgvarg[0].lVal);\n    else\n        return S_OK;\n}\n')),(0,r.kt)("h4",{id:"implementing-event-functions"},"Implementing event functions"),(0,r.kt)("p",null,"With ",(0,r.kt)("inlineCode",{parentName:"p"},"IDispatch")," implemented the scanner sink will invoke its supported events. Per the UPOS specification, when the sink invokes a data event, subsequent data events are automatically suspended because ",(0,r.kt)("inlineCode",{parentName:"p"},"OPOSScanner.DataEventEnabled")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),", resulting in queueing of subsequent data events. ",(0,r.kt)("inlineCode",{parentName:"p"},"DataEventEnabled")," must be reset to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," to continue receiving more data events."),(0,r.kt)("p",null,"For the purpose of this tutorial, the scanned label data will simply be printed to the console."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScannerSink.cpp\nHRESULT ScannerSink::DataEvent(long Status)\n{\n    std::cout << "Data: " << scanner.ScanDataLabel << std::endl;\n    scanner.DataEventEnabled = true;\n    return S_OK;\n}\n')),(0,r.kt)("h2",{id:"connecting-the-scanner-and-the-sink"},"Connecting the scanner and the sink"),(0,r.kt)("p",null,"Now we must inform the scanner of the sink. To do this query an ",(0,r.kt)("inlineCode",{parentName:"p"},"IConnectionPointContainer")," interface by calling\n",(0,r.kt)("inlineCode",{parentName:"p"},"QueryInterface()")," from the scanner. On the connection point container, get the interface of the ",(0,r.kt)("inlineCode",{parentName:"p"},"_IOPOSScannerEvents")," connection point by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"FindConnectionPoint()"),". Now a connection can be established between the scanner and the sink by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"Advise()")," on the connection point."),(0,r.kt)("p",null,"The following code can be seen in context in the segment ",(0,r.kt)("a",{parentName:"p",href:"#together"},"Tying it all together"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"IConnectionPointContainer *cpc;\nscanner->QueryInterface(IID_IConnectionPointContainer, (void **) &cpc);\n\nIConnectionPoint *cp; \ncpc->FindConnectionPoint(__uuidof(OposScanner_CCO::_IOPOSScannerEvents), &cp);\ncpc->Release();\n\nScannerSink *sink = new ScannerSink(*scanner); \nDWORD cookie;\ncp->Advise(sink, &cookie);\n")),(0,r.kt)("h2",{id:"tying-it-all-together"},"Tying it all together"),(0,r.kt)("p",null,"As any experienced developer knows, a huge part of writing code is defensive programming, guarding against potential errors. So be aware, for the sake of brevity, this tutorial has avoided addressing the myriad issues you may encounter."),(0,r.kt)("p",null,"That said, a more complete example can be found in the ",(0,r.kt)("a",{parentName:"p",href:"./datalogicoposexamples"},"Datalogic OPOS Examples"),"."),(0,r.kt)("p",null,"Refactoring a little, we can move shared #include and #import statements to a common location (ScannerSink.h in this tutorial)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// ScannerSink.h\n#include <windows.h>\n#include <string>\n#include <iostream>\n\n// This import statement causes generation of OPOSScanner.tlh and OPOSScanner.tli\n#import "progid:OPOS.Scanner"\n\n// This import statement informs the IDE of the COM interface and everything in the\n// namespace OposScanner_CCO, but is not required for compilation.\n#import "libid:ccb90180-b81e-11d2-ab74-0040054c3719"\n')),(0,r.kt)("p",null,"Doing that simplifies the main file a little. Finally, we can add the code connecting the scanner to the sink.",(0,r.kt)("a",{name:"together"})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "ScannerSink.h"\n#include <processthreadsapi.h>\n\nstatic DWORD threadID;\nstatic BOOL handler(DWORD event);\n\nint main()\n{\n    // Setup the console program to exit gracefully.\n    threadID = GetCurrentThreadId();\n    SetConsoleCtrlHandler((PHANDLER_ROUTINE)(handler), TRUE);\n\n    // Load and initialize the COM library.\n    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);\n\n    // Create a COM object and point to it.\n    OposScanner_CCO::IOPOSScannerPtr scanner;\n    scanner.CreateInstance("OPOS.Scanner");\n\n    // Open a context with the scanner (e.g. "USBScanner").\n    std::string profileName("<your selected profile>");\n    scanner->Open(profileName.c_str());\n\n    // Claim control of the scanner using a 1000 millisecond timeout.\n    scanner->ClaimDevice(1000L);\n    if (scanner->Claimed)\n    {\n        // The scanner has been opened and claimed.\n\n        // Enable the device, label decoding and transmission of event data.\n        scanner->DeviceEnabled = true;\n        scanner->DataEventEnabled = true;\n        scanner->DecodeData = true;\n\n        // Determine whether scanner is connectable\n        IConnectionPointContainer* cpc;\n        bool isConnectable = (scanner->QueryInterface(IID_IConnectionPointContainer, (void**)&cpc) == S_OK);\n\n        if (isConnectable)\n        {\n            // Determine whether _IOPOSScannerEvents connection point is supported.\n            IConnectionPoint* cp;\n            bool haveConnectionPoint = (cpc->FindConnectionPoint(__uuidof(OposScanner_CCO::_IOPOSScannerEvents), &cp) == S_OK);\n            cpc->Release();\n\n            if (haveConnectionPoint)\n            {\n                ScannerSink* sink = new ScannerSink(*scanner);\n\n                // Connect cp with sink (subscribe to the sink).\n                // cookie is a token representing the connection,\n                // used later when deleting the connection.\n                DWORD cookie;\n                cp->Advise(sink, &cookie);\n\n                std::cout << "Press \\\'Ctrl + C\\\' to quit." << std::endl;\n\n                // The scanner message loop. Events will be handled by the methods of the sink.\n                static MSG msg = { 0 };\n                while (GetMessage(&msg, 0, 0, 0))\n                {\n                    TranslateMessage(&msg);\n                    DispatchMessage(&msg);\n                }\n\n                // Delete the connection (unsubscribe from the sink).\n                cp->Unadvise(cookie);\n                cp->Release();\n            }\n        }\n\n        // Disable, release and close the scanner.\n        scanner->DeviceEnabled = false;\n        scanner->ReleaseDevice();\n        scanner->Close();\n    }\n\n    // Release the COM object\n    scanner.Release();\n\n    // Unload libraries on this thread.\n    CoUninitialize();\n    return 0;\n}\n\nBOOL handler(DWORD event)\n{\n    PostThreadMessage(threadID, WM_QUIT, 0, 0);\n    return TRUE;\n}\n')))}m.isMDXComponent=!0}}]);